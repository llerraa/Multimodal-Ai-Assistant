# -*- coding: utf-8 -*-
"""Educational_Assistant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12G3b7_xagzzZzeceHWvkD_h-kJGgSUfc

# üéì AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤

**–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
- üá∑üá∫ –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫
- üìù –î–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (BLIP-large)
- ‚ùì 5 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
- üéØ 2 –≤–æ–ø—Ä–æ—Å–∞ –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
- üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã (–Ω–µ –ø–æ–≤—Ç–æ—Ä—è—é—Ç—Å—è)

# –ü—Ä–æ–µ–∫—Ç –≤—ã–ø–æ–ª–Ω–∏–ª–∏:
- –ü–µ—Ä–µ–≤–æ–∑—á–∏–∫–æ–≤–∞ –í–∞–ª–µ—Ä–∏—è –î–º–∏—Ç—Ä–∏–µ–≤–Ω–∞ (—Å—Ç.–±.: 1032259214)
- –†–æ–∂–¥–µ—Å—Ç–≤–µ–Ω—Å–∫–∏–π –ï–≤–≥–µ–Ω–∏–π (—Å—Ç.–±.: )

## 1Ô∏è‚É£ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install transformers gradio accelerate Pillow torch torchvision sentencepiece sacremoses

"""## 2Ô∏è‚É£ –ò–º–ø–æ—Ä—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫"""

import torch
from PIL import Image
from transformers import BlipProcessor, BlipForConditionalGeneration
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM
import gradio as gr
import random
import time
from typing import List, Dict, Tuple
import warnings
warnings.filterwarnings('ignore')

print("‚úÖ –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã")
print(f"üéÆ GPU –¥–æ—Å—Ç—É–ø–µ–Ω: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"üìä GPU: {torch.cuda.get_device_name(0)}")

"""## 3Ô∏è‚É£ –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–µ–π"""

blip_model = None
blip_processor = None
translation_model = None
translation_tokenizer = None
device = None

def initialize_models():
    global blip_model, blip_processor, translation_model, translation_tokenizer, device

    print("üöÄ –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–µ–π...\n")

    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"üì± –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device.upper()}")

    # BLIP-large –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω—ã—Ö –æ–ø–∏—Å–∞–Ω–∏–π
    print("\nüì∏ –ó–∞–≥—Ä—É–∑–∫–∞ BLIP-large...")
    blip_processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-large")
    blip_model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-large")
    blip_model.to(device)
    blip_model.eval()
    print("   ‚úÖ BLIP-large –∑–∞–≥—Ä—É–∂–µ–Ω")

    # NLLB –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
    print("\nüåç –ó–∞–≥—Ä—É–∑–∫–∞ NLLB-200...")
    translation_tokenizer = AutoTokenizer.from_pretrained(
        "facebook/nllb-200-distilled-600M",
        src_lang="eng_Latn",
        tgt_lang="rus_Cyrl"
    )
    translation_model = AutoModelForSeq2SeqLM.from_pretrained("facebook/nllb-200-distilled-600M")
    translation_model.to(device)
    translation_model.eval()
    print("   ‚úÖ NLLB-200 –∑–∞–≥—Ä—É–∂–µ–Ω\n")

    print("‚úÖ –í—Å–µ –º–æ–¥–µ–ª–∏ –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–±–æ—Ç–µ!")
    return device

device = initialize_models()

"""## 4Ô∏è‚É£ –§—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–≤–æ–¥–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞"""

def translate_to_russian(text: str) -> str:
    """–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞"""
    try:
        inputs = translation_tokenizer(text, return_tensors="pt", padding=True, truncation=True, max_length=512)
        inputs = {k: v.to(device) for k, v in inputs.items()}

        with torch.no_grad():
            translated = translation_model.generate(
                **inputs,
                forced_bos_token_id=translation_tokenizer.convert_tokens_to_ids("rus_Cyrl"),
                max_length=512
            )

        translated_text = translation_tokenizer.decode(translated[0], skip_special_tokens=True)

        # –ü—Ä–∏–≤–æ–¥–∏–º –ø–µ—Ä–≤—É—é –±—É–∫–≤—É –∫ —Å—Ç—Ä–æ—á–Ω–æ–π –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
        if translated_text and translated_text[0].isupper():
            translated_text = translated_text[0].lower() + translated_text[1:]

        return translated_text

    except Exception as e:
        print(f"      ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
        return text

def analyze_image_detailed(image: Image.Image) -> Tuple[str, str]:
    """–î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    try:
        print("   üìä –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
        start_time = time.time()

        inputs = blip_processor(images=image, return_tensors="pt").to(device)

        print("      ü§ñ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è...")
        with torch.no_grad():
            generated_ids = blip_model.generate(
                **inputs,
                max_length=75,
                num_beams=5,
                length_penalty=1.0,
                early_stopping=True
            )

        description_en = blip_processor.decode(generated_ids[0], skip_special_tokens=True)
        print(f"      ‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ (EN): {description_en}")

        print("      üîÑ –ü–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π...")
        description_ru = translate_to_russian(description_en)
        # –î–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–≥–ª–∞–≤–Ω—É—é –±—É–∫–≤—É
        description_ru = description_ru[0].upper() + description_ru[1:] if description_ru else description_ru
        print(f"      ‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ (RU): {description_ru}")

        elapsed = time.time() - start_time
        print(f"   ‚è±Ô∏è  –í—Ä–µ–º—è –∞–Ω–∞–ª–∏–∑–∞: {elapsed:.2f} —Å–µ–∫")

        return description_en, description_ru

    except Exception as e:
        print(f"   ‚ùå –û—à–∏–±–∫–∞: {e}")
        return "Error", "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"

print("‚úÖ –§—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")

"""## 5Ô∏è‚É£ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤"""

def generate_unique_wrong_answers(correct_answer: str, description: str, question_type: str) -> List[str]:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –£–ù–ò–ö–ê–õ–¨–ù–´–• –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø–∏—Å–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""

    desc_lower = description.lower()
    words = description.split()

    # –ë–∞–∑–æ–≤—ã–µ –ø—É–ª—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    wrong_pools = {
        'content': [
            # –ù–∞—É—á–Ω—ã–µ/—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ
            "detailed molecular structure diagram with chemical bonds",
            "complex scientific schematic showing cellular processes",
            "technical blueprint with engineering specifications",
            "anatomical illustration of biological systems",
            "mathematical graph showing algebraic functions",
            # –ì–µ–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ
            "topographical map with elevation contours",
            "satellite imagery showing terrain features",
            "geological survey map with mineral deposits",
            "navigational chart with maritime routes",
            # –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ/–∞—Ä—Ö–∏–≤–Ω—ã–µ
            "historical photograph from archival collection",
            "vintage document with handwritten notes",
            "archaeological artifact photograph",
            "museum exhibit documentation image",
            # –•—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ
            "abstract artistic composition with colors",
            "classical painting reproduction",
            "modern graphic design illustration",
            "architectural rendering visualization"
        ],
        'category': [
            "three-dimensional computer-generated model",
            "hand-drawn sketch or illustration",
            "photographic still life composition",
            "animated video frame capture",
            "infographic with icon elements",
            "technical cross-section diagram",
            "flowchart with process steps",
            "mind map with hierarchical structure",
            "timeline showing chronological events",
            "scatter plot with data points"
        ],
        'purpose': [
            "educational demonstration for student training",
            "scientific research documentation",
            "industrial quality control assessment",
            "marketing and promotional presentation",
            "safety instruction and warning display",
            "entertainment and recreational viewing",
            "archival preservation and documentation",
            "diagnostic analysis and evaluation",
            "comparison and benchmarking study",
            "trend analysis and pattern recognition"
        ],
        'context': [
            "medical diagnostics and healthcare",
            "engineering design and manufacturing",
            "financial analysis and investment",
            "environmental monitoring and ecology",
            "agricultural planning and farming",
            "urban planning and architecture",
            "transportation and logistics",
            "telecommunications and networking",
            "energy production and distribution",
            "retail and consumer services"
        ]
    }

    # –ü–æ–ª—É—á–∞–µ–º –ø—É–ª –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤–æ–ø—Ä–æ—Å–∞
    pool = wrong_pools.get(question_type, wrong_pools['content'])

    # –§–∏–ª—å—Ç—Ä—É–µ–º –æ—Ç–≤–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ù–ï —Å–æ–¥–µ—Ä–∂–∞—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è
    # –≠—Ç–æ –¥–µ–ª–∞–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –±–æ–ª–µ–µ –ø—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–Ω—ã–º–∏, –Ω–æ —Ç–æ—á–Ω–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏
    key_words = set(word.lower() for word in words if len(word) > 4)

    filtered_pool = []
    for answer in pool:
        answer_words = set(word.lower() for word in answer.split() if len(word) > 4)
        # –ò—Å–∫–ª—é—á–∞–µ–º –æ—Ç–≤–µ—Ç—ã —Å –±–æ–ª—å—à–∏–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º —Å–ª–æ–≤
        if len(key_words & answer_words) < 2:
            filtered_pool.append(answer)

    # –ï—Å–ª–∏ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –æ—Å—Ç–∞–ª–æ—Å—å –º–∞–ª–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—Å—å –ø—É–ª
    if len(filtered_pool) < 3:
        filtered_pool = pool

    # –°–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º 3 –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–∞
    selected = random.sample(filtered_pool, min(3, len(filtered_pool)))

    return selected

print("‚úÖ –§—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")

"""## 6Ô∏è‚É£ –£–º–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤"""

def extract_key_concepts(description: str) -> Dict[str, str]:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è"""
    desc_lower = description.lower()
    words = description.split()

    concepts = {
        'main_object': description,
        'detail': ' '.join(words[-4:]) if len(words) > 4 else description,
        'category': determine_category(desc_lower),
        'purpose': determine_purpose(desc_lower),
        'context': determine_context(desc_lower)
    }

    return concepts

def determine_category(description: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    if any(word in description for word in ['chart', 'graph', 'diagram']):
        if 'pie' in description:
            return "circular pie chart visualization"
        elif 'bar' in description:
            return "bar chart or column graph"
        elif 'line' in description:
            return "line graph or trend chart"
        else:
            return "data visualization chart"
    elif any(word in description for word in ['map', 'weather', 'geographic']):
        return "geographical or meteorological map"
    elif any(word in description for word in ['photo', 'picture', 'image']):
        return "photographic image or picture"
    else:
        return "informational graphic or diagram"

def determine_purpose(description: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ"""
    if any(word in description for word in ['weather', 'forecast', 'climate']):
        return "weather forecasting and meteorological analysis"
    elif any(word in description for word in ['sales', 'revenue', 'business', 'financial']):
        return "business analysis and performance tracking"
    elif any(word in description for word in ['data', 'statistics', 'chart']):
        return "data visualization and statistical presentation"
    elif any(word in description for word in ['scientific', 'research', 'study']):
        return "scientific research and academic study"
    else:
        return "information presentation and communication"

def determine_context(description: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è"""
    if any(word in description for word in ['weather', 'meteorological']):
        return "meteorology and atmospheric sciences"
    elif any(word in description for word in ['business', 'sales', 'financial']):
        return "business intelligence and corporate analytics"
    elif any(word in description for word in ['medical', 'health', 'clinical']):
        return "healthcare and medical diagnostics"
    elif any(word in description for word in ['education', 'teaching', 'learning']):
        return "education and academic instruction"
    else:
        return "professional information analysis"

def generate_questions_smart(description_en: str, description_ru: str) -> List[Dict]:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 5 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏"""
    print("   üìù –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤...")

    concepts = extract_key_concepts(description_en)
    questions = []

    # –í–æ–ø—Ä–æ—Å 1: –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—ä–µ–∫—Ç (–ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é)
    print("      –í–æ–ø—Ä–æ—Å 1/5 (–æ—Å–Ω–æ–≤–Ω–æ–π –æ–±—ä–µ–∫—Ç)...")
    q1_answer_en = concepts['main_object']
    q1_answer_ru = translate_to_russian(q1_answer_en)
    q1_wrong_en = generate_unique_wrong_answers(q1_answer_en, description_en, 'content')
    q1_wrong_ru = [translate_to_russian(ans) for ans in q1_wrong_en]
    questions.append(create_question(
        "–ß—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –æ—Å–Ω–æ–≤–Ω—ã–º –æ–±—ä–µ–∫—Ç–æ–º, –∏–∑–æ–±—Ä–∞–∂—ë–Ω–Ω—ã–º –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–µ?",
        q1_answer_ru,
        q1_wrong_ru,
        "content"
    ))
    print("         ‚úÖ –°–æ–∑–¥–∞–Ω")

    # –í–æ–ø—Ä–æ—Å 2: –î–µ—Ç–∞–ª–∏ (–ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é)
    print("      –í–æ–ø—Ä–æ—Å 2/5 (–∫–ª—é—á–µ–≤—ã–µ –¥–µ—Ç–∞–ª–∏)...")
    q2_answer_en = concepts['detail']
    q2_answer_ru = translate_to_russian(q2_answer_en)
    q2_wrong_en = generate_unique_wrong_answers(q2_answer_en, description_en, 'content')
    q2_wrong_ru = [translate_to_russian(ans) for ans in q2_wrong_en]
    questions.append(create_question(
        "–ö–∞–∫–∏–µ –∫–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏?",
        q2_answer_ru,
        q2_wrong_ru,
        "content"
    ))
    print("         ‚úÖ –°–æ–∑–¥–∞–Ω")

    # –í–æ–ø—Ä–æ—Å 3: –ö–∞—Ç–µ–≥–æ—Ä–∏—è
    print("      –í–æ–ø—Ä–æ—Å 3/5 (—Ç–∏–ø –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏)...")
    q3_answer_en = concepts['category']
    q3_answer_ru = translate_to_russian(q3_answer_en)
    q3_wrong_en = generate_unique_wrong_answers(q3_answer_en, description_en, 'category')
    q3_wrong_ru = [translate_to_russian(ans) for ans in q3_wrong_en]
    questions.append(create_question(
        "–ö–∞–∫–æ–π —Ç–∏–ø –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω?",
        q3_answer_ru,
        q3_wrong_ru,
        "category"
    ))
    print("         ‚úÖ –°–æ–∑–¥–∞–Ω")

    # –í–æ–ø—Ä–æ—Å 4: –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
    print("      –í–æ–ø—Ä–æ—Å 4/5 (—Ü–µ–ª—å/–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ)...")
    q4_answer_en = concepts['purpose']
    q4_answer_ru = translate_to_russian(q4_answer_en)
    q4_wrong_en = generate_unique_wrong_answers(q4_answer_en, description_en, 'purpose')
    q4_wrong_ru = [translate_to_russian(ans) for ans in q4_wrong_en]
    questions.append(create_question(
        "–ö–∞–∫–æ–≤–∞ —Ü–µ–ª—å –∏–ª–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ç–æ–≥–æ, —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ?",
        q4_answer_ru,
        q4_wrong_ru,
        "purpose"
    ))
    print("         ‚úÖ –°–æ–∑–¥–∞–Ω")

    # –í–æ–ø—Ä–æ—Å 5: –ö–æ–Ω—Ç–µ–∫—Å—Ç
    print("      –í–æ–ø—Ä–æ—Å 5/5 (–∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è)...")
    q5_answer_en = concepts['context']
    q5_answer_ru = translate_to_russian(q5_answer_en)
    q5_wrong_en = generate_unique_wrong_answers(q5_answer_en, description_en, 'context')
    q5_wrong_ru = [translate_to_russian(ans) for ans in q5_wrong_en]
    questions.append(create_question(
        "–í –∫–∞–∫–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∏–ª–∏ –æ–±–ª–∞—Å—Ç–∏ —ç—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–º–µ–Ω—è—Ç—å—Å—è?",
        q5_answer_ru,
        q5_wrong_ru,
        "context"
    ))
    print("         ‚úÖ –°–æ–∑–¥–∞–Ω")

    print(f"   ‚úÖ –°–æ–∑–¥–∞–Ω–æ {len(questions)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤")
    return questions

def create_question(question_text: str, correct_answer: str, wrong_answers: List[str], qtype: str) -> Dict:
    """–°–æ–∑–¥–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤–æ–ø—Ä–æ—Å–∞ —Å –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏"""
    all_answers = [correct_answer] + wrong_answers[:3]
    random.shuffle(all_answers)

    correct_index = all_answers.index(correct_answer)

    return {
        "question": question_text,
        "answers": all_answers,
        "correct_answer": correct_index,
        "correct_text": correct_answer,
        "type": qtype
    }

def format_questions_output(questions: List[Dict]) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    output = "üìù **–°–ì–ï–ù–ï–†–ò–†–û–í–ê–ù–ù–´–ï –¢–ï–°–¢–û–í–´–ï –í–û–ü–†–û–°–´**\n\n"

    content_questions = sum(1 for q in questions if q.get('type') == 'content')
    output += f"üìä –í–æ–ø—Ä–æ—Å–æ–≤ –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: **{content_questions}**\n"
    output += f"üìö –í—Å–µ–≥–æ –≤–æ–ø—Ä–æ—Å–æ–≤: **{len(questions)}**\n\n"
    output += "="*50 + "\n\n"

    for i, q in enumerate(questions, 1):
        marker = "üéØ" if q.get('type') == 'content' else "üìå"
        output += f"{marker} **–í–æ–ø—Ä–æ—Å {i}:** {q['question']}\n\n"

        for j, answer in enumerate(q['answers'], 1):
            check = "‚úÖ" if j-1 == q['correct_answer'] else "  "
            # –ü–µ—Ä–≤–∞—è –±—É–∫–≤–∞ —Å—Ç—Ä–æ—á–Ω–∞—è, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞
            output += f"{check} {j}. {answer}\n"

        output += f"\nüí° **–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç:** {q['correct_text']}\n"
        output += "\n" + "="*50 + "\n\n"

    output += "\n**–£—Å–ª–æ–≤–Ω—ã–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è:**\n"
    output += "üéØ ‚Äî –≤–æ–ø—Ä–æ—Å –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n"
    output += "üìå ‚Äî –æ–±—â–∏–π –≤–æ–ø—Ä–æ—Å\n"

    return output

print("‚úÖ –§—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")

"""## 7Ô∏è‚É£ –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏"""

def process_image(image: Image.Image, progress=gr.Progress()) -> Tuple[str, str]:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤"""
    if image is None:
        return "‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", ""

    try:
        print("\n" + "="*60)
        print("üéØ –ù–ê–ß–ê–õ–û –û–ë–†–ê–ë–û–¢–ö–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø")
        print("="*60)

        start_total = time.time()

        # –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        progress(0.3, desc="–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
        description_en, description_ru = analyze_image_detailed(image)

        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏
        progress(0.7, desc="–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤...")
        questions = generate_questions_smart(description_en, description_ru)

        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        progress(0.95, desc="–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤...")
        description_output = f"üîç **–û–ü–ò–°–ê–ù–ò–ï –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø:**\n\n{description_ru}\n\n"
        description_output += f"_–û—Ä–∏–≥–∏–Ω–∞–ª (EN): {description_en}_"

        questions_output = format_questions_output(questions)

        progress(1.0, desc="–ì–æ—Ç–æ–≤–æ!")

        total_time = time.time() - start_total
        print(f"\n‚úÖ –û–ë–†–ê–ë–û–¢–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê –∑–∞ {total_time:.2f} —Å–µ–∫")
        print("="*60 + "\n")

        return description_output, questions_output

    except Exception as e:
        error_msg = f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {str(e)}"
        print(f"\n{error_msg}\n")
        import traceback
        traceback.print_exc()
        return error_msg, error_msg

print("‚úÖ –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ—Ç–æ–≤–∞")

"""## 8Ô∏è‚É£ –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""

with gr.Blocks(title="AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤") as interface:
    gr.Markdown(
        """
        # üéì AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
        ## ‚ö° –§–∏–Ω–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚Äî –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã

        **–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
        - üá∑üá∫ –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫
        - üìù –î–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (BLIP-large)
        - ‚ùì 5 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
        - üéØ 2 –≤–æ–ø—Ä–æ—Å–∞ –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        - üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã (–Ω–µ –ø–æ–≤—Ç–æ—Ä—è—é—Ç—Å—è –º–µ–∂–¥—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏)
        - ‚ö° –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞ 10‚Äì20 —Å–µ–∫—É–Ω–¥ –Ω–∞ GPU

        ---
        """
    )

    with gr.Row():
        with gr.Column(scale=1):
            image_input = gr.Image(
                type="pil",
                label="üì∏ –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
                height=400
            )

            process_btn = gr.Button(
                "üöÄ –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã",
                variant="primary",
                size="lg"
            )

            gr.Markdown(
                """
                ### üí° –ü–æ–¥—Å–∫–∞–∑–∫–∏:
                - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á—ë—Ç–∫–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                - –ü–æ–¥—Ö–æ–¥—è—Ç: –≥—Ä–∞—Ñ–∏–∫–∏, —Å—Ö–µ–º—ã, –¥–∏–∞–≥—Ä–∞–º–º—ã, —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
                - –§–æ—Ä–º–∞—Ç—ã: JPG, PNG, WEBP

                ### ‚ö° –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
                - ‚úÖ –ë—ã—Å—Ç—Ä–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ (10‚Äì20 —Å–µ–∫)
                - ‚úÖ –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
                - ‚úÖ –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
                - ‚úÖ 2 –≤–æ–ø—Ä–æ—Å–∞ –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é
                - ‚úÖ –ù–µ—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π –º–µ–∂–¥—É —Ç–µ—Å—Ç–∞–º–∏
                """
            )

        with gr.Column(scale=1):
            description_output = gr.Textbox(
                label="üìù –û–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è",
                lines=6
            )

            questions_output = gr.Textbox(
                label="üìã –¢–µ—Å—Ç–æ–≤—ã–µ –≤–æ–ø—Ä–æ—Å—ã (5 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö)",
                lines=35
            )

    gr.Markdown(
        """
        ---
        ### üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏:
        - **–ú–æ–¥–µ–ª—å –∞–Ω–∞–ª–∏–∑–∞:** BLIP-large (–¥–µ—Ç–∞–ª—å–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è)
        - **–ú–æ–¥–µ–ª—å –ø–µ—Ä–µ–≤–æ–¥–∞:** NLLB-200 (–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä—É—Å—Å–∫–∏–π)
        - **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–æ–≤:** –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        - **–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ:** GPU (T4) ‚Äî Google Colab
        - **–í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:** 10‚Äì20 —Å–µ–∫—É–Ω–¥

        ### ‚ú® –£–ª—É—á—à–µ–Ω–∏—è:
        - –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        - –ò—Å–∫–ª—é—á–∞—é—Ç—Å—è –≤–∞—Ä–∏–∞–Ω—Ç—ã —Å —Å–æ–≤–ø–∞–¥–∞—é—â–∏–º–∏ –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
        - –ö–∞–∂–¥–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞—ë—Ç –Ω–æ–≤—ã–π –Ω–∞–±–æ—Ä –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
        - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ (—Ä–µ–≥–∏—Å—Ç—Ä, —Å–∫–ª–æ–Ω–µ–Ω–∏—è)
        """
    )

    process_btn.click(
        fn=process_image,
        inputs=[image_input],
        outputs=[description_output, questions_output]
    )

print("\n" + "="*60)
print("üåê –ó–ê–ü–£–°–ö –§–ò–ù–ê–õ–¨–ù–û–ì–û –ò–ù–¢–ï–†–§–ï–ô–°–ê")
print("="*60)
print(f"üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device.upper()}")
print("‚è±Ô∏è  –í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: 10‚Äì20 —Å–µ–∫—É–Ω–¥")
print("üé≤ –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã: –î–ê")
print("üéØ –í–æ–ø—Ä–æ—Å–æ–≤ –ø–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é: 2")
print("="*60 + "\n")

interface.launch(debug=True, share=True)